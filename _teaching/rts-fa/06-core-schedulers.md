---
title: "الگوریتم‌های پایهٔ زمان‌بندی در سیستم‌های بلادرنگ"
collection: teaching
type: "Course Module"
permalink: /teaching/rts-fa/core-schedulers
course: "سیستم‌های بلادرنگ"
order: 7
mathjax: true
use_math: true
layout: course
lang: fa
alt_lang: en
alt_url: /teaching/rts/core-schedulers
---

# الگوریتم‌های پایهٔ زمان‌بندی در سیستم‌های بلادرنگ 

---

##  بازیِ صف و نوبت

تصور کن وارد یک نانوایی می‌شی. دو تا شیوهٔ سرویس وجود داره:
- یکی: هرکس زودتر اومده، زودتر نون می‌گیره (مثل FCFS).  
- دیگری: نانوا اول کسانی که حجم سفارش‌شون کمتره رو آماده می‌کنه تا کل صف سریع‌تر جمع بشه (مثل SJF).  
- یا فرض کن پیک موتوری داری، بعضی سفارش‌ها باید سریع برسن (deadline) — اون‌ها اولویت دارن (مثل EDF).

سیستم‌های بلادرنگ دقیقاً با همین مسئله روبه‌رو هستند؛ باید تصمیم بگیرند **چه کاری زودتر اجرا شود** تا زمان‌های مشخص (deadlines) رعایت شوند.

---

## کلیدواژه‌ها (به زبان ساده)
- **Task / Job / Request**: کاری که باید انجام شود (مثلاً کسی دکمهٔ آسانسور را فشار می‌دهد، یا تسکی در پردازنده اجرا می‌شود).  
- **Preemptive (قابل قطع)**: می‌توان اجرای یک کار را وسطش قطع کرد و کار دیگری را اجرا کرد.  
- **Non-preemptive (غیرقابل قطع)**: وقتی کاری شروع شد تا تمام نشود، قطع نمی‌شود.  
- **Deadline (مهلت)**: تا چه زمانی کار باید تمام شود.  
- **Utilization (بهره‌وری / اشغال پردازنده)**: مجموع زمان اجرایی نسبت به فواصل — چقدر از زمان را کارها اشغال می‌کنند.  
- **Schedulable**: یعنی با آن الگوریتم و ویژگی‌ها می‌توان همهٔ deadlineها را رعایت کرد.

---

## فهرست الگوریتم‌های پایه که باید بلد باشی
1. FCFS — First Come First Served  
2. SJF / SRTF — Shortest Job First / Shortest Remaining Time First  
3. Round Robin (RR)  
4. Priority Scheduling (+ مشکلات مثل Priority Inversion)  
5. RMS — Rate Monotonic Scheduling  
6. EDF — Earliest Deadline First  
7. LLF — Least Laxity First  

---

## ۱ — FCFS (First Come First Served)
### ایدهٔ کلی (عامیانه)
مثل صف نانوایی: هر کس زودتر بیاید، زودتر خدمت می‌شود.

### رفتار فنی
- کارها بر اساس زمان ورود در صف قرار می‌گیرند.
- غیرقابل پیش‌دستی یا قابل پیش‌دستی می‌تواند باشد؛ معمولاً نسخهٔ ساده‌اش غیرقابل پیش‌دستی است.

### مثال ساده
- نفر A ساعت ۰ می‌آید و کاری که 10 دقیقه طول می‌کشد دارد.  
- نفر B ساعت ۱ می‌آید و کاری که 1 دقیقه طول می‌کشد دارد.  
در FCFS، B باید تا زمانی که A تمام شود منتظر بماند.

### نتیجهٔ عملی
- ساده و عادلانه.  
- مشکل: **Convoy Effect** — یک کار سنگین می‌تواند باعث شود کارهای کوتاه بسیاری عقب بمانند و deadlineها نقض شوند.

### کی استفاده شود؟
وقتی سادگی و عدل مهم است و deadline سخت وجود ندارد.

---

## ۲ — SJF / SRTF (Shortest Job First / Shortest Remaining Time First)
### ایدهٔ کلی
همان نانوا که سفارش‌های کوچک را زودتر آماده می‌کند تا صف سریع‌تر جمع شود.

### تفاوت‌ها
- **SJF**: غیرقابل پیش‌دستی؛ از میان کارهای حاضر، آن‌هایی که زمان اجرا کوتاه‌تر دارند انتخاب می‌شوند.  
- **SRTF**: پیش‌دستی (preemptive)؛ اگر کاری وارد شود که اجرای باقیمانۀ آن کمتر است، اجرای جاری قطع می‌شود و کاری جدید اجرا می‌شود.

### مثال
- A وارد می‌شود (10 min)، سپس B وارد می‌شود (1 min). در SJF/SRTF، B ممکن است قبل از ادامهٔ A اجرا شود.

### مزایا / معایب
- مزیت: میانگین زمان انتظار را کاهش می‌دهد.  
- عیب: برای اجرا باید طول اجرای کارها را بدانیم یا تخمین بزنیم — که همیشه ممکن نیست. و باعث **ستاره‌دار شدن (starvation)** کارهای طولانی می‌شود.

---

## ۳ — Round Robin (RR)
### ایدهٔ کلی
مثل بچه‌هایی که سرِ نوبت برای بازی با کامپیوتر هر کدام ۵ دقیقه می‌گیرند؛ سپس نفر بعدی می‌آید.

### رفتار فنی
- هر کار یک اسلایس زمانی (time slice یا quantum) دارد.
- بعد از اتمام اسلایس، اگر کار تمام نشده باشد، به انتهای صف بازمی‌گردد.

### مزایا / معایب
- مناسب برای fairness و زمان پاسخ تعاملی.  
- در بلادرنگ سخت (hard real-time) مناسب نیست مگر تنظیمات دقیقی صورت گیرد؛ ممکن است باعث شود deadlineها نقض شوند.

---

## ۴ — Priority Scheduling (زمان‌بندی مبتنی بر اولویت)
### ایدهٔ کلی
همان اورژانس بیمارستان: بیمار با وضعیت بحرانی (اولویت بالا) زودتر درمان می‌شود.

### رفتار فنی
- هر تسک یک اولویت دارد؛ بالاترین اولویت اجرا می‌شود.
- می‌تواند preemptive (اگر تسکی با اولویت بالاتر برسد، کار فعلی قطع می‌شود) یا non-preemptive باشد.

### مشکل کلاسیک: Priority Inversion
فرض کن:
- تسک L (low) قفلِ منبعی را گرفته.
- تسک H (high) نیاز به همان منبع دارد و می‌خواهد اجرا شود.
- اما یک تسک M (medium) که اولویت متوسط دارد، می‌آید و CPU را می‌گیرد.
در نتیجه H عملاً باید منتظر M شود — این **وارونگی اولویت** است.

### راه‌حل‌ها
- **Priority Inheritance**: وقتی H منتظر L است، L موقتاً اولویت H را به ارث می‌برد تا سریع‌تر کارش را تمام کند.  
- **Priority Ceiling**: هر منبع سقفی دارد؛ وقتی تسکی قفل را می‌گیرد تا زمانی که قفل آزاد نشود، فقط تسک‌هایی با اولویت بالاتر از سقف نمی‌توانند اجرا شوند — پیچیده‌تر اما امن‌تر.

---

## ۵ — RMS (Rate Monotonic Scheduling)
### زمینه و ایده
- مخصوص تسک‌های **دوره‌ای** (Periodic tasks) — یعنی کارهایی که هر T ثانیه یکبار باید اجرا شوند.
- قانون ساده: **هرچه دوره کوتاه‌تر باشد، اولویت بالاتری دارد** (یعنی تسک‌هایی که بیشتر باید اجرا شوند، اولویت بالاتر).

### مثال عامیانه
فرض کن کلاس‌های مدرسه: بعضی در هر هفته دوبار برگزار می‌شوند (دوره کوتاه‌تر) — آنها اولویت بیشتری دارند برای تخصیص زمانِ اتاق.

### قابلیت‌ها و فرمول مهم
- این الگوریتم **ثابت اولویت** است (priority ثابت با توجه به دوره).  
- یک قاعدهٔ ساده برای تضمین schedulability وجود دارد (Liu & Layland):
  برای n تسک، اگر مجموع بهره‌وری (utilization) \( U = \sum_{i=1}^n \frac{C_i}{T_i} \) (که \(C_i\) زمان اجرا و \(T_i\) دورهٔ تسک هست) از مقدار زیر کمتر یا مساوی باشد، تضمین می‌شود:

\[
U \le n(2^{1/n} - 1)
\]

برای مثال:
- اگر n = 1 → bound = 1.0  
- اگر n = 2 → bound ≈ 0.828  
- اگر n → ∞ → bound → ln 2 ≈ 0.693

> توجه: این «قید» **کافی** اما **نه ضروری** است؛ یعنی اگر U کمتر از این bound باشد حتماً schedulable است، اما اگر بیشتر باشد ممکن است باز هم schedulable باشد و نیاز به تحلیل دقیق‌تری باشد (response-time analysis).

### محدودیت‌ها
- فقط برای تسک‌های دوره‌ای و مستقل درست عمل می‌کند.
- برای تسک‌های دارای منابع مشترک، باید قفل‌ها و وارونگی اولویت را مدیریت کرد.

---

## ۶ — EDF (Earliest Deadline First)
### ایدهٔ کلی (عامیانه)
مثل پیک موتوری که همیشه سفارش با نزدیک‌ترین مهلت را زودتر می‌زند.

### رفتار فنی
- هر بار اجرا، تسکی که نزدیک‌ترین deadline دارد انتخاب می‌شود.
- **برای تک-پردازنده، EDF الگوریتم بهینه است** یعنی اگر مجموعه‌ای از تسک‌ها قابل زمان‌بندی باشد (schedulable) با هر الگوریتمی، EDF آن‌ها را هم زمان‌بندی می‌کند — به شرطی که فرضیات کلاسیک برقرار باشند (تسک‌های مستقل، پیش‌بینی‌پذیر و ...).

### قابلیتها/معایب
- اگر مجموع utilization \(U = \sum C_i/T_i \le 1\) برای تسک‌های دوره‌ای باشد، EDF می‌تواند آن‌ها را زمان‌بندی کند (شرط لازم و کافی تحت فرضیات کلاسیک).  
- اما EDF نیاز به مرتب‌سازی دائمی و مدیریت deadlineها دارد (overhead اجرایی).

### مثال ساده
سه پرسش با deadline‌های متفاوت: جواب‌دهی برای نزدیک‌ترین deadline در اولویت قرار می‌گیرد.

---

## ۷ — LLF (Least Laxity First)
### ایدهٔ کلی
**Laxity** یا slack (فضای آزاد) = \( \text{deadline} - (\text{زمان فعلی} + \text{زمان باقی‌مانده برای اجرا}) \).

- تسکی که کمترین Laxity را دارد، باید اول اجرا شود (چون فضای مانور کمتری دارد).

### مثال
اگر یک سفارش پیتزا ۵ دقیقه زمان اجرا دارد و ۸ دقیقه تا مهلتش مانده، laxity = 8 - (now + 5). هر چه مقدار کمتر، اضطراری‌تر است.

### مزایا/معایب
- خیلی دقیق و حساس به واقعیتِ زمان‌های باقیمانده.  
- اما محاسبهٔ مداوم Laxity و preemption زیاد باعث سربار (overhead) می‌شود.

---

## پیش‌فرض‌ها و نکات عملی (که در هر الگوریتم باید در نظر بگیری)
- آیا تسک‌ها **دوره‌ای** یا **آنی** (aperiodic / sporadic) هستند؟  
- آیا زمان اجرای هر تسک (WCET) معلوم است یا خیر؟  
- هزینهٔ Preemption (قطع و بازگشت) را در نظر بگیر — در بعضی سخت‌افزارها سنگینه.  
- منابع مشترک و قفل‌ها (mutexes) را مدیریت کن (Priority Inversion).  
- Overhead اجرایی الگوریتم (مثلاً مرتب‌سازی برای EDF) را در محاسبات بهره‌وری لحاظ کن.

---

## جدول خلاصه (چک‌لیست سریع)

| الگوریتم | مناسب برای | مزیت | بدی |
|---------:|:-----------:|:-----:|:----:|
| FCFS | سادگی، سیستم‌های non-real | ساده، عادلانه | بد برای deadlineهای سخت |
| SJF/SRTF | زمانی که طول اجرا معلوم است | میانگین wait پایین | نیاز به اطلاعات زمان اجرا، خطر starvation |
| RR | سیستم‌های تعاملی | fairness | نه مناسب برای hard RT بدون تنظیم |
| Priority | وقتی اولویت منطقیه | انعطاف‌پذیر | priority inversion |
| RMS | تسک‌های دوره‌ای | تحلیل‌پذیر، ثابت | فقط دوره‌ای، bound کافی ولی ناتمام |
| EDF | deadline-oriented | بهینه در تک-پردازنده | overhead مرتب‌سازی |
| LLF | حساس به laxity | دقیق برای جلوگیری از misses | overhead بالا، preemption فراوان |

---

## مثال گام‌به‌گام (اعداد ساده برای فهم)
فرض کن ۳ تسک داریم (دوره‌ای فرض می‌کنیم برای RMS/EDF بررسی):

- Task A: \(C_A=1\), \(T_A=4\)  (هر 4 ثانیه 1 ثانیه اجرا)
- Task B: \(C_B=2\), \(T_B=5\)
- Task C: \(C_C=5\), \(T_C=20\)

محاسبهٔ Utilization:

\[
U = \frac{1}{4} + \frac{2}{5} + \frac{5}{20} = 0.25 + 0.4 + 0.25 = 0.90
\]

- برای **EDF**: چون \(U = 0.90 \le 1.0\) → در نظریهٔ کلاسیک تک-پردازنده، EDF این مجموعه را زمان‌بندی می‌کند (یعنی اگر سایر فرضیات برقرار باشند deadlineها رعایت می‌شود).
- برای **RMS**: با n=3، bound ≈ \(3(2^{1/3}-1) \approx 0.78\). چون \(U = 0.90 > 0.78\) پس قاعدهٔ سادهٔ Liu-Layland تضمین نمی‌کند؛ اما این **به‌معنی‌ عدم‌قابلیت زمان‌بندی نیست** — فقط باید تحلیل دقیق‌تری انجام دهیم (مثلاً response-time analysis) تا بفهمیم RMS می‌تواند یا نه.

---

## Priority Inversion — مثالی واقعی و راه‌حل ساده
### مثال عامیانه
- ماشین خراب (منبع مشترک) — مکانیک کم‌تجربه (Low priority) در حال تعمیر است.  
- رئیس (High priority) به ماشین نیاز دارد.  
- در همین زمان راننده (Medium priority) از بیرون می‌آید و کار دیگری می‌کند و مانع مکانیک می‌شود — نتیجه: رئیس باید منتظر راننده شود، که منطقی نیست.

### راه‌حل ساده
- **Priority Inheritance**: وقتی رئیس منتظر مکانیک است، مکانیک موقتا اولویت رئیس را می‌گیرد تا زودتر کار را تمام کند.

---

## تمرین‌های پیشنهادی (برای دانشجو)
1. **مثال‌سازی FCFS**: سه درخواست (A: 10s @ t=0، B:1s @ t=1، C:2s @ t=2). محاسبه کن wait و response برای هرکدام در FCFS.  
2. **SRTF شبیه‌سازی دستی**: همان مثال را در SRTF شبیه‌سازی کن و مقایسه کن.  
3. **RMS vs EDF**: با مثال عددی بالا (A,B,C) یک جدول زمان‌بندی 20 ثانیه‌ای بنویس و ببین کدام الگوریتم ها deadlineها را رعایت می‌کنند.  
4. **Priority Inversion**: مثالی بساز که نشان دهد یک تسک high چگونه می‌تواند به‌دلیل low و medium معطل شود و سپس Priority Inheritance را اعمال کن و اثر را ببین.

---

## نکات آموزشی برای استاد
- از مثال‌های بصری و فیزیکی (نانوایی، اتوبوس، پیک، اورژانس) استفاده کن — دانشجو سریع ارتباط می‌گیرد.  
- تمرین‌های دستی (paper scheduling) بسیار آموزنده‌اند قبل از ورود به ابزارهای شبیه‌سازی.  
- نمایش گرافیکی timeline (step plot) و histogram زمان پاسخ را برای فهم بهتر نشان بده.  
- هنگام معرفی RMS/EDF حتماً مفهوم Utilization را با مثال عددی ببَرش (مثال بالا عالیه).

---

## منابع پیشنهادی برای مطالعهٔ دقیق‌تر (کتاب-محور)
- Liu, Jane W.S., *Real-Time Systems* — مرجع کلاسیک.  
- Liu & Layland (1973) — مقالهٔ کلاسیک در مورد RMS.

---

## جای عکس‌ها (قرار دادن در فایل نهایی)
- `![صف نانوایی — مثال FCFS](path/to/bakery.jpg)`  
- `![اتوبوس — مثال SCAN](path/to/bus.jpg)`  
- `![پیک موتوری — مثال EDF](path/to/delivery.jpg)`  
- `![مقایسه الگوریتم‌ها](path/to/comparison-diagram.png)`

---

### پایان — خلاصهٔ خیلی کوتاه
- FCFS ساده و عادلانه است، اما برای deadlineهای سخت مناسب نیست.  
- RMS و EDF دو الگوریتم اساسی و مهم برای سیستم‌های بلادرنگ‌اند: RMS برای تسک‌های دوره‌ای با اولویت ثابت، EDF برای رعایت دقیق deadlineها (اولویت پویا).  
- مفاهیم عملی مثل **Priority Inversion** را فراموش نکن — در عمل مهم‌تر از فرمول‌هاست.

---